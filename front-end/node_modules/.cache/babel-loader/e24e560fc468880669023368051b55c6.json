{"ast":null,"code":"'use strict';\n\nvar url = require('url');\n\nexports = module.exports = function historyApiFallback(options) {\n  options = options || {};\n  var logger = getLogger(options);\n  return function (req, res, next) {\n    var headers = req.headers;\n\n    if (req.method !== 'GET') {\n      logger('Not rewriting', req.method, req.url, 'because the method is not GET.');\n      return next();\n    } else if (!headers || typeof headers.accept !== 'string') {\n      logger('Not rewriting', req.method, req.url, 'because the client did not send an HTTP accept header.');\n      return next();\n    } else if (headers.accept.indexOf('application/json') === 0) {\n      logger('Not rewriting', req.method, req.url, 'because the client prefers JSON.');\n      return next();\n    } else if (!acceptsHtml(headers.accept, options)) {\n      logger('Not rewriting', req.method, req.url, 'because the client does not accept HTML.');\n      return next();\n    }\n\n    var parsedUrl = url.parse(req.url);\n    var rewriteTarget;\n    options.rewrites = options.rewrites || [];\n\n    for (var i = 0; i < options.rewrites.length; i++) {\n      var rewrite = options.rewrites[i];\n      var match = parsedUrl.pathname.match(rewrite.from);\n\n      if (match !== null) {\n        rewriteTarget = evaluateRewriteRule(parsedUrl, match, rewrite.to, req);\n\n        if (rewriteTarget.charAt(0) !== '/') {\n          logger('We recommend using an absolute path for the rewrite target.', 'Received a non-absolute rewrite target', rewriteTarget, 'for URL', req.url);\n        }\n\n        logger('Rewriting', req.method, req.url, 'to', rewriteTarget);\n        req.url = rewriteTarget;\n        return next();\n      }\n    }\n\n    var pathname = parsedUrl.pathname;\n\n    if (pathname.lastIndexOf('.') > pathname.lastIndexOf('/') && options.disableDotRule !== true) {\n      logger('Not rewriting', req.method, req.url, 'because the path includes a dot (.) character.');\n      return next();\n    }\n\n    rewriteTarget = options.index || '/index.html';\n    logger('Rewriting', req.method, req.url, 'to', rewriteTarget);\n    req.url = rewriteTarget;\n    next();\n  };\n};\n\nfunction evaluateRewriteRule(parsedUrl, match, rule, req) {\n  if (typeof rule === 'string') {\n    return rule;\n  } else if (typeof rule !== 'function') {\n    throw new Error('Rewrite rule can only be of type string or function.');\n  }\n\n  return rule({\n    parsedUrl: parsedUrl,\n    match: match,\n    request: req\n  });\n}\n\nfunction acceptsHtml(header, options) {\n  options.htmlAcceptHeaders = options.htmlAcceptHeaders || ['text/html', '*/*'];\n\n  for (var i = 0; i < options.htmlAcceptHeaders.length; i++) {\n    if (header.indexOf(options.htmlAcceptHeaders[i]) !== -1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getLogger(options) {\n  if (options && options.logger) {\n    return options.logger;\n  } else if (options && options.verbose) {\n    return console.log.bind(console);\n  }\n\n  return function () {};\n}","map":{"version":3,"names":["url","require","exports","module","historyApiFallback","options","logger","getLogger","req","res","next","headers","method","accept","indexOf","acceptsHtml","parsedUrl","parse","rewriteTarget","rewrites","i","length","rewrite","match","pathname","from","evaluateRewriteRule","to","charAt","lastIndexOf","disableDotRule","index","rule","Error","request","header","htmlAcceptHeaders","verbose","console","log","bind"],"sources":["C:/Users/Person/Desktop/Epicodus/React/SimpleMembership/front-end/node_modules/connect-history-api-fallback/lib/index.js"],"sourcesContent":["'use strict';\n\nvar url = require('url');\n\nexports = module.exports = function historyApiFallback(options) {\n  options = options || {};\n  var logger = getLogger(options);\n\n  return function(req, res, next) {\n    var headers = req.headers;\n    if (req.method !== 'GET') {\n      logger(\n        'Not rewriting',\n        req.method,\n        req.url,\n        'because the method is not GET.'\n      );\n      return next();\n    } else if (!headers || typeof headers.accept !== 'string') {\n      logger(\n        'Not rewriting',\n        req.method,\n        req.url,\n        'because the client did not send an HTTP accept header.'\n      );\n      return next();\n    } else if (headers.accept.indexOf('application/json') === 0) {\n      logger(\n        'Not rewriting',\n        req.method,\n        req.url,\n        'because the client prefers JSON.'\n      );\n      return next();\n    } else if (!acceptsHtml(headers.accept, options)) {\n      logger(\n        'Not rewriting',\n        req.method,\n        req.url,\n        'because the client does not accept HTML.'\n      );\n      return next();\n    }\n\n    var parsedUrl = url.parse(req.url);\n    var rewriteTarget;\n    options.rewrites = options.rewrites || [];\n    for (var i = 0; i < options.rewrites.length; i++) {\n      var rewrite = options.rewrites[i];\n      var match = parsedUrl.pathname.match(rewrite.from);\n      if (match !== null) {\n        rewriteTarget = evaluateRewriteRule(parsedUrl, match, rewrite.to, req);\n\n        if(rewriteTarget.charAt(0) !== '/') {\n          logger(\n            'We recommend using an absolute path for the rewrite target.',\n            'Received a non-absolute rewrite target',\n            rewriteTarget,\n            'for URL',\n            req.url\n          );\n        }\n\n        logger('Rewriting', req.method, req.url, 'to', rewriteTarget);\n        req.url = rewriteTarget;\n        return next();\n      }\n    }\n\n    var pathname = parsedUrl.pathname;\n    if (pathname.lastIndexOf('.') > pathname.lastIndexOf('/') &&\n        options.disableDotRule !== true) {\n      logger(\n        'Not rewriting',\n        req.method,\n        req.url,\n        'because the path includes a dot (.) character.'\n      );\n      return next();\n    }\n\n    rewriteTarget = options.index || '/index.html';\n    logger('Rewriting', req.method, req.url, 'to', rewriteTarget);\n    req.url = rewriteTarget;\n    next();\n  };\n};\n\nfunction evaluateRewriteRule(parsedUrl, match, rule, req) {\n  if (typeof rule === 'string') {\n    return rule;\n  } else if (typeof rule !== 'function') {\n    throw new Error('Rewrite rule can only be of type string or function.');\n  }\n\n  return rule({\n    parsedUrl: parsedUrl,\n    match: match,\n    request: req\n  });\n}\n\nfunction acceptsHtml(header, options) {\n  options.htmlAcceptHeaders = options.htmlAcceptHeaders || ['text/html', '*/*'];\n  for (var i = 0; i < options.htmlAcceptHeaders.length; i++) {\n    if (header.indexOf(options.htmlAcceptHeaders[i]) !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction getLogger(options) {\n  if (options && options.logger) {\n    return options.logger;\n  } else if (options && options.verbose) {\n    return console.log.bind(console);\n  }\n  return function(){};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}